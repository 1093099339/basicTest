  
  
### 什么是死锁
   - 多个线程各自占有一些系统资源，并且互相等待其它线程占有的资源才能运行，而导致两个或多个线程都在等待对方先释放资源，都停止执行的情形
     某一个同步块同时拥有 “两个以上对象的锁” 时，就可能会发生 “死锁” 的情形。
         
   - 产生死锁的四个必要条件：
           互斥条件        ：一个资源每次只能被一个进程使用
           请求与保持条件  ：一个进程因请求资源而阻塞时，对已获得的资源保持不放
           不剥夺条件     ：进程已获得的资源，在为使用完之前，不能强行剥夺
           循环等待条件   ： 若干进程之间形成一种头尾相接的循环等待资源关系。
        
          只要想办法破除任意一个或多个条件就可以避免死锁的发生。
  
  
 ### 生产者消费者问题

   - 这是一个线程同步问题，生产者和消费者共享同一个资源，并且生产者和消费者之间相互依赖，互为条件.
         对于生产者，没有生产产品之前，要通知消费者等待﹒而生产了产品之后，又需要马上通知消费者消费
         对于消费者﹐在消费之后，要通知生产者已经结束消费，需要生产新的产品以供消费.
         
   - 在生产者消费者问题中﹐仅有synchronized是不够的
        synchronized 可阻止并发更新同一个共享资源，实现了同步
        synchronized不能用来实现不同线程之间的消息传递(通信)
   
   - java 提供了几个方法解决线程之间的通信问题 
     都是 Object 类的方法，都只能在同步方法或者同步代码块中使用，否则会抛出 illegalMonitorStateException 异常
     
        wait()              :表示线程一直等待，直到其它线程通知，与sleep不同，会释放锁
        wait( long timeout)
        notify()            ：唤醒一个处于等待状态的线程
        notifyALll()
   
   - 解决方式一：     
        加入缓冲区
        生产者和消费者不直接交流，通过缓冲区进行操作
        
   - 解决方式二：
        信号灯方法
        
   

