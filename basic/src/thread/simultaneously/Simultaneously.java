package thread.simultaneously;

/**
 * @program: basicTest
 * @description: 并发操作
 * @author: 全栈者也
 * @create: 2020 - 10 - 21 17:12
 **/
public class Simultaneously {

    /**
     * 同一个资源，多人都想使用
     * 多个线程访问一个对象，并且某些线程还想修改这个对象，这时候我们就需要线程同步，线程同步其实就是一个等待机制
     * 多个需要访问此对象的线程进入 对象的的等待池 形成队列，等待前面线程使用完毕后，下一个线程再使用
     *
     * 为了保证数据再方法中被访问的正确性，在访问是加入了锁机制  synchronized ,
     * 当一个线程获得对象的排它锁，独占资源，其它线程必须等待，使用后释放锁即可：
     * 存放以下问题：
     *              一个线程持有锁会导致其它需要此锁的线程高高挂起
     *              在多线程竞争下， 加锁，释放锁会导致比较多的上下文切换 和 调度延时，引起性能问题
     *              如果一个优先级高的锁等待一个优先级低的锁，就会导致优先级倒置问题，引起性能问题。
     *
     *  同步方法：
     *       我们可以通过 private 关键字来保证数据对象只能被方法访问，所以我们只需要针对方法提出一套解决机制
     *       这套机制就是 synchronized 关键字： 包括了 synchronized 方法和 synchronized 块
     *       synchronized 方法控制对“对象”的访问，每个对象对应一把锁，每个synchronized方法都必须获得调用该方法的对象的锁才能执行，否则线程会阻塞
     *       方法一旦执行，就独占该锁，直到该方法返回才释放锁，后面被阻塞的线程才获得这个锁，继续执行。
     *
     *       public synchronized void method(){}
     *       若将一个大的方法申明为 synchronized 将会影响效率
     *
     *
     *
     */





}
